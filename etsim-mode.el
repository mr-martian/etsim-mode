(require 'transient)
(require 'cl)

(defvar etsim-mode-hook nil)

(defun etsim-on-normal-word ()
  (save-excursion
    (beginning-of-line)
    (looking-at "[0-9]+\t")))

(defun etsim-on-any-word ()
  (save-excursion
    (beginning-of-line)
    (looking-at "[0-9]")))

(defun etsim-is-last-word ()
  (save-excursion
    (next-line)
    (beginning-of-line)
    (looking-at "$")))

(defun etsim-is-first-word ()
  (save-excursion
    (previous-line)
    (beginning-of-line)
    (not (looking-at "[0-9]"))))

(defun etsim-beginning-of-sentence ()
  (save-excursion
    (beginning-of-line)
    (unless (= (point) (point-min))
      (search-backward-regexp "^$" (point-min) t))
    (point)))

(defun etsim-end-of-sentence ()
  (save-excursion
    (beginning-of-line)
    (let ((p (point)))
      (search-forward-regexp "^$" (point-max) t)
      (if (= p (point))
          (point-max)
        (point)))))

(defun etsim-make-overlays ()
  (cl-flet ((mk-overlay (start col)
                        (let ((o (make-overlay start (point))))
                          (overlay-put o 'etsim-col col))))
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (beginning-of-line)
        (when (etsim-on-any-word)
          (let ((line-start (point))
                (cur-start (point))
                (line-end (save-excursion (end-of-line) (point))))
            ; TODO: we're assuming everything is valid
            (dotimes (i 9)
              (search-forward "\t" line-end t)
              (mk-overlay cur-start (+ i 1))
              (setq cur-start (point)))
            (end-of-line)
            (mk-overlay cur-start 10)
            (mk-overlay line-start 0)))
        (forward-line 1)))))

(defun etsim-align-overlays (ovs)
  (cl-flet ((owidth (o) (- (overlay-end o) (overlay-start o))))
    (let ((width (reduce #'max (cons 0 (mapcar #'owidth ovs)))))
      (dolist (o ovs)
        (let ((nw (+ 1 (- width (owidth o)))))
          (overlay-put o 'after-string (make-string nw ?\s))
          (overlay-put o 'etsim-width nw))))))

(defun etsim-overlay-get (o p)
  (plist-get (overlay-properties o) p))

(defun etsim-filter-col (ovs col)
  (cl-remove-if-not (lambda (o)
                      (= (or (etsim-overlay-get o 'etsim-col) -1) col))
                    ovs))

(defun etsim-get-all-column (col)
  (etsim-filter-col (overlays-in (point-min) (point-max)) col))

(defun etsim-show-column (col)
  (interactive)
  (mapcar (lambda (o)
            (overlay-put o 'invisible nil)
            (overlay-put o 'after-string
                         (make-string (etsim-overlay-get o 'etsim-width) ?\s)))
          (etsim-get-all-column col)))

(defun etsim-hide-column (col)
  (interactive)
  (mapcar (lambda (o)
            (overlay-put o 'invisible t)
            (overlay-put o 'after-string ""))
          (etsim-get-all-column col)))

(defun etsim-next-sentence ()
  (interactive)
  (search-forward-regexp "^$" (point-max) t)
  (next-line))

(defun etsim-get-arcs (start end)
  (cl-flet ((first-in (oin ovs)
                      (dolist (o ovs)
                        (when (and (<= (overlay-start oin) (overlay-start o))
                                   (<= (overlay-end o) (overlay-end oin)))
                          (return (string-to-number
                                   (buffer-substring
                                    (overlay-start o)
                                    (overlay-end o))))))))
    (let* ((start (etsim-beginning-of-sentence))
           (end (etsim-end-of-sentence))
           (ovs (overlays-in start end))
           (lines (etsim-filter-col ovs 0))
           (ids (etsim-filter-col ovs 1))
           (heads (etsim-filter-col ovs 7))
           (arr (sort (apply
                       #'vector
                       (mapcar (lambda (o)
                                 (let ((i (first-in o ids))
                                       (h (first-in o heads)))
                                   (if (and i h)
                                       (list o i h 0 nil)
                                     (list o nil nil 0 t))))
                               lines))
                      (lambda (ls1 ls2)
                        (< (overlay-start (car ls1))
                           (overlay-start (car ls2))))))
           (ln (length arr))
           (todo-count 1))
      (while (> todo-count 0)
        (setq todo-count 0)
        (dotimes (i ln)
          (unless (nth 4 (elt arr i))
            (let* ((h-min 0)
                   (clear t)
                   (wi (elt arr i))
                   (wii (cadr wi))
                   (wih (nth 3 wi)))
              (dotimes (j ln)
                (let* ((wj (elt arr j)) (wji (cadr wj)))
                  (when (and (cadr wj) ; it's a word
                             (or (< wii wji wih)
                                 (< wih wji wii)))
                    (when (> (nth 3 wj) h-min)
                      (setq h-min (nth 3 wj)))
                    (unless (nth 4 wj)
                      (setq clear nil)))))
              (setf (elt arr i) (list (car wi) wii wih (1+ h-min) clear))
              (unless clear (setq todo-count (1+ todo-count)))))))
      (let* ((str-width (apply #'max (mapcar (lambda (l) (nth 3 l)) arr)))
             (strs (apply #'vector (mapcar (lambda (_)
                                             (make-string (* str-width 2) ?\s))
                                           arr))))
        (dotimes (i ln)
          (let* ((on nil)
                 (wi (elt arr i))
                 (idx (cadr wi))
                 (head (nth 2 wi))
                 (height (* 2 (nth 3 wi))))
            (dotimes (j ln)
              (let ((wj (elt arr j)))
                (cond
                 ((= (cadr wj) idx)
                  (setq on (not on)))
                 ((= (cadr wj) head)
                  (setq on (not on)))
                 (on (if (= (elt (elt strs j) height) ?─)
                         (aset (elt strs j) height ?┼)
                       (aset (elt strs j) height ?│))))))))
        (dotimes (i ln)
          (overlay-put (car (elt arr i)) 'after-string (elt strs i)))))))
                    

(defun etsim-setup ()
  (etsim-make-overlays)
  (save-excursion
    (goto-char (point-min))
    (while (not (eobp))
      (let* ((s (etsim-beginning-of-sentence))
             (e (etsim-end-of-sentence))
             (ovs (overlays-in s e)))
        (dotimes (i 10)
          (etsim-align-overlays (etsim-filter-col ovs (+ i 1))))
        (etsim-get-arcs s e))
      (etsim-next-sentence)))
  ;(etsim-hide-column 5)
  (etsim-hide-column 6)
  (etsim-hide-column 10))

(defun etsim-next-word ()
  (interactive)
  (next-line))

(defun etsim-assign-keys ()
  (define-key etsim-mode-map (kbd "f") #'etsim-next-word))

(define-derived-mode etsim-mode fundamental-mode "CoNLL-U"
  "CoNLL-U with trees"
  (setq-local tab-width 1)
  (read-only-mode)
  (etsim-assign-keys)
  (let ((debug-on-error t))
    (etsim-setup))
  (run-hooks 'etsim-mode-hook))

(add-to-list 'auto-mode-alist '("\\.conllu\\'" . etsim-mode))

(provide 'etsim-mode)
